class KeyVault is subclass of GLOBAL
types
	private KeyVaultState = <Idle> |
        <WaitingForJoinRequest> |
        <WaitingForChallengeSolvedReply> |
        <WaitingForChallengeRequest> |
        <WaitingForNewEffectivePublicKey> |
        <WaitingForNewEffectiveCertificateAcknowledgement> |
        <WaitingForNewEffectivePublicKeyDuringRekeying> |
		<Connected> |
        <Undefined>;

    private ControllerWithKeyVaultState :: 
        controller : Controller
        keyVaultState: KeyVaultState;

values
	private sparePartStatesSequence: seq of KeyVaultState = [
		<Idle>,
		<WaitingForJoinRequest>,
		<WaitingForChallengeSolvedReply>,
		<WaitingForChallengeRequest>,
		<WaitingForNewEffectivePublicKey>,
		<WaitingForNewEffectiveCertificateAcknowledgement>,
		<Connected>
	];
	
	private controllerStatesSequence: seq of KeyVaultState = [
		<Connected>,
		<WaitingForNewEffectivePublicKeyDuringRekeying>,
		<WaitingForNewEffectiveCertificateAcknowledgement>
	];

instance variables
    private controllers: map token to ControllerWithKeyVaultState := { |-> };

    inv forall controllerId in set dom controllers & controllers(controllerId).keyVaultState <> undefinedState;

operations
	public NextState: Message ==> ()
	NextState(message) == (
		cases message.getMessageType():
			"ReceiveKeyVaultSearchBroadcastAcknoledgement" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForJoinRequest>, message),
			"SendChallenge" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForChallengeSolvedReply>, message),
			"SendChallengeReplyVerification" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForChallengeRequest>, message),
			"SendChallenge" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForNewEffectivePublicKey>, message),
			"SendNewEffectiveCertificate" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForNewEffectiveCertificateAcknowledgement>, message),
			"SendNewEffectiveCertificateAcknoledgement" -> ModifyKeyVaultStateForControllerFromMessage(<Connected>, message),
			"SenRekeyRequest" -> ModifyKeyVaultStateForControllerFromMessage(<WaitingForNewEffectivePublicKeyDuringRekeying>, message),
			others -> ModifyKeyVaultStateForControllerFromMessage(undefinedState, message)
		end;
	)
    pre message.getControllerId() in set dom controllers
	post (
		if controllers(message.getControllerId()).controller.GetMode() = <SparePart> then 
			controllers(message.getControllerId()).keyVaultState = GetNextStateFromSequenceUsingCurrentState[KeyVaultState](sparePartStatesSequence, (controllers~)(message.getControllerId()).keyVaultState) -- controllers~ is the previous controllers object
		else 
			controllers(message.getControllerId()).keyVaultState = GetNextStateFromSequenceUsingCurrentState[KeyVaultState](controllerStatesSequence, (controllers~)(message.getControllerId()).keyVaultState) 
	) and controllers(message.getControllerId()).keyVaultState <> (controllers~)(message.getControllerId()).keyVaultState;

	private ModifyKeyVaultStateForControllerFromMessage: KeyVaultState * Message ==> ()
	ModifyKeyVaultStateFomControllerWithId(newState, message) == (
		controllers := controllers ++ {message.getControllerId() |-> {controller: controllers(message.getControllerId()).controller, keyVaultState: newState}}
	)
	pre message.getControllerId() in set dom controllers;

end KeyVault